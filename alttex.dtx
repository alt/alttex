% \iffalse
% This is alttex.dtx, a small experimental package.
% 
% This code is public domain.
% 
%% Author: Arno L. Trautmann, mail: arno dot trautmann at gmx dot de
%%
%
%<+package|driver>
%<+package>\NeedsTeXFormat{LaTeX2e}
%<+package>\ProvidesPackage{alttex}[]
%
%<*driver>
%\documentclass[12pt]{ltxdoc}
% \usepackage{alttex}
\documentclass{ltxdoc}
\usepackage{ifxetex}
\ifxetex
  \usepackage{xltxtra}
\else
  \errmessage{No XeLaTeX -> no alttex! See the log for more information.}
  \typeout{^^J%
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!^^J%
  ! This package can only be compiled with XeLaTeX.^^J%
  ! pdfLaTeX cannot handle unicode the way it is used here.^^J%
  ! If you want to have support for [utf8]inputenc,^^J%
  ! please contact the author.^^J%
  ! If you want to use LuaLaTeX, give it a try:^^J%
  ! You have to take away everything that requires XeTeX.^^J%
  ! That is xltxtra and every \fontspec call. Also you have ^^J%
  ! to define a dummy for \XeLaTeX…^^J%
  ! Please e-mail me the result of your experiences!^^J%
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!^^J%
  }
  \endinput
\fi
\usepackage[english]{babel}
\usepackage{
todonotes,
lmodern
}

\title{The \textsf{alttex} package}
\author{Arno L. Trautmann\thanks{arno.trautmann@gmx.de}}
\date{Version 0.a.3 \today}

\begin{document}
\DocInput{alttex.dtx}
\end{document}
%</driver>
%
% \fi
% \iffalse metacomment:
% The following definition has to be made at this strange position for some reasons. It checks whether the font DejaVu Sans is installed on your system or not. If so, it will be used to display some characters the lmodern font does not have. If the font is not present, you will not see the symbol, but your .sty file still will be fine.
% end metacomment \fi
% \newif\ifFontIsAvailable
% \def\testFontAvailability#1{
%   \count255=\interactionmode
%   \batchmode
%   \let\preload=\nullfont
%   \font\preload="#1" at 10pt
%   \ifx\preload\nullfont \FontIsAvailablefalse
%   \else \FontIsAvailabletrue \fi
%   \interactionmode=\count255
% }
% \def\setdeja{\setmonofont[Scale=0.85]{DejaVu Sans Mono}}
% \def\dejawarning{}
% \testFontAvailability{DejaVu Sans}
% \ifFontIsAvailable
%   \setdeja\else
%   \def\dejawarning{\footnotetext{\bf You do not have the font DejaVu Sans Mono installed. Get it from http://dejavu-fonts.org.\\ Your .sty file created will be fine, but in the pdf there will be some symbols missing.}}\fi
% 
% \maketitle
% \dejawarning This is the package |alttex| which will try to give an experimental new way to write \XeLaTeX{}\footnote{If you don’t know about \XeLaTeX, see the appendix.\ref{xelatex}} code. So far it is mostly done with very dirty code and actually it’s a collection of things that come into my mind during boring lectures. Maybe someone will have fun with the following code fragments.
% \tableofcontents
% \newpage
% \section{introduction}
% The problem I have with \LaTeX\footnote{I’ll write \LaTeX{} instead of \XeLaTeX—saves me two keystrokes. Most of the code below \emph{only} works with \XeLaTeX. If you need support for [utf8]inputenc or Lua\LaTeX, please contact the author.}  is the antique way of typing. Because most people still use a hopelessly outdated keyboard layout (»qwerty« or slightly adapted versions of that), \LaTeX{} doesn’t make use of some cool features. I’m not talking about writing chinese or arabic text! Maybe this example will make the idea clear:
% 
% In standard \LaTeX, one has to write
% \begin{verbatim}
% This is the normal text, then comes the itemization:
% \begin{itemize}
%   \item text for first item
%   \item \begin{itemize}
%         \item this is an item inside an item…
%         \item[$\Rightarrow$] Here an item with a formula: $\int_a^b x^2 dx$
%         \end{itemize}
%   \item and the outer itemize goes on…
% \end{itemize}
% \end{verbatim}
% 
% Using this package and having a superior keyboard layout\footnote{E.\,g. the ergonomic layout Neo: \url{http://neo-layout.org/}}, you can simply write:\footnote{The lmodern font I’m using here does not have the symbol for the inner item , so we change to DejaVu Sans Mono here.}
% 
% \begin{verbatim}
% This is the normal text, then comes the itemization:
% 
% • text for first item
% • 
% 
%   ‣ this is an item inside an item
%   ‣[⇒] Here an item with a formula: $∫_a^b x² dx$
%   
% • and the outer itemize goes on…
% 
% And your normal text goes on…
% \end{verbatim}
% Well, actually I’m lying now because this is not fully implemented so far. But it’s the aim of this package to provide this – besides many, many other funny and cool things. The aim is to offer a more „wysiwyg“ way, without loosing anything of logical markup. One still can re|\def|ine the |•| if he doesn’t like the way his items look.
% I have just started to write the package, there will be much more stuff here in the future.
% 
% Ok, enough blahblah, now comes the code. We begin with the uninteresting preamble stuff:
%    \begin{macrocode}
\ProvidesPackage{alttex}

\RequirePackage{amsmath}
%    \end{macrocode}
% \begin{macro}{\usepackage}
% Now, this is the first highlight. It is an extremely simple and stupid approach to load missing packages on-the-fly, just like Mik\TeX{} does. We re|\def|ine the |\usepackage| and hope, it works. Only working with texlive! If you’re using Mik\TeX{}, put a
% \begin{verbatim}  \let\usepacke\oldpackage\end{verbatim} into your preamble, \emph{directly} after loading |alttex|. If this does not work, delete the following lines from your |alttex.sty|.
%    \begin{macrocode}
\let\oldpackage\usepackage
\def\usepackage#1{
  \IfFileExists{#1.sty}{
    \oldpackage{#1}
  }{
    \immediate\write18{tlmgr install #1}
  }
}
%    \end{macrocode}
% \end{macro}
% So far, this code seems to be a bit buggy, but it should work anyhow.
% 
% Now load some nice packages and testing wether you’re running \XeLaTeX{} or not.
%    \begin{macrocode}
\RequirePackage{exscale}
\RequirePackage{ifxetex}
\RequirePackage{hhline}
\ifxetex
\typeout{Loading XeTeX, everything’s fine.}
\else
  \typeout{^^J%
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!^^J%
  ! This package can only be compiled with XeLaTeX.^^J%
  ! pdfLaTeX cannot handle unicode the way it is used here.^^J%
  ! If you want to have support for [utf8]inputenc, please contact the author.^^J%
  ! If you want to use LuaLaTeX, give it a try:^^J%
  ! comment out the lines 32,33,35–43.^^J%
  ! Please e-mail me the result of your experiences!^^J%
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!^^J%
  }
  \errmessage{No XeLaTeX, no alttex. See the log for more information.}
  \endinput
\fi

%    \end{macrocode}
% We need |exscale| to write really big formulae, and |ifxetex| to check wether one uses the correct engine.
% \section{Textmode}
% \subsection{no escape}
% \begin{macro}{\noescape}
% You want to write plain text. Maybe you’re annoyed by always escaping characters like \_ \^ \# \& \{ \} \$ \textasciitilde{} and so on. |\noescape| allows you to never escape anything—except the \textbackslash, which still might be used for |\textit{}| or so. Or maybe not… because the \{ \} are not escaped. Have to think about this one. Maybe the \textbackslash{} will be redefined to define \{ \} by itself.
%    \begin{macrocode}
\def\noescape{
  \catcode`\_= 11%
  \catcode`\^= 11%
  \catcode`\#= 11%
  \catcode`\&= 11%
  %\catcode`\{= 11%
  %\catcode`\}= 11%
  \catcode`\$= 11%
  \catcode`\~= 11%
  \makeatletter%
  \catcode`\%= 11
}
%    \end{macrocode}
% The |\makeatletter| is not necessary. But it fitted into this line, so I will leave it here.
% \end{macro}
% \begin{macro}{\oldescape}
% Of course this has to be reset when doing anything like formula, tabular etc. Maybe I will be able to change the behaviour automatically. This idea has been inspired by a discussion on the Con\TeX{}t mailinglist.
%    \begin{macrocode}
\def\oldescape{
  \catcode`\%= 14%
  \catcode`\_= 8%
  \catcode`\^= 7%
  \catcode`\#= 6%
  \catcode`\&= 4%
  %\catcode`\{= 1%
  %\catcode`\}= 2%
  \catcode`\$= 3%
  \catcode`\~= 13%
  \makeatother%
}
%    \end{macrocode}
% \end{macro}
% \subsection{tabular}
% The way one has to type extensive tabulars is quite complex – and the resulting code is often not easy to read. I don’t have good ideas how to change this, but I’m thinking about it. Mail me any suggestions for this!
%
% This will be the first attempt to make tabulars easier: Mostly you want an |\hline| after an |\\|. So let’s try something like:\todo{I will try to implement cool stuff from the \textsf{hhline}-package.}
% \begin{macro}{\§ for \\\hhline}
% Type |\–| (an en-dash) at the end of a line, and you get an |\hhline|. Type |\=| to get a double line
%    \begin{macrocode}
\def\–{\hhline}
\def\={\hhline}
%    \end{macrocode}
% This is shurely not a good symbol for this purpose, but I don’t have a better idea so far. At least it’s a ”bar“, so one can guess what it should do. 
% \end{macro}
% 
% \subsection{excel tabulars}
% \begin{macro}{\exceltabular}
% Often one usese a program to calculate tabulars of numbers. To insert it into \LaTeX, one has to do some work. Here we try to copy-paste the tabular from excel, Calc or any other program to a file mytabular.txt (or any other ending). Then you say |\exceltabular{mytabular}| (you do not need the ending, therefor it doesn’t matter) and you get the tabular in a standard format. I will extend this to enable caption, variable number of columns, kind of rule used etc. This is just a very first test.
% 
% This is the definition of the command:
%    \begin{macrocode}
\def\exceltabular#1{
  \catcode`\^^I=4\relax
  \eolintabular%
  \begin{tabular}{|c|c|c|}\hline%
  \input{#1}%
  \end{tabular}%
  \catcode`\^^M=5\relax
}
%    \end{macrocode}
% And a little helper function to make the <enter> |\active|. Again, thanks to the people on the mailinglists.
%    \begin{macrocode}
\def\mybreak{\\\hline}
\begingroup
  \lccode`\~=`\^^M%
\lowercase{%
  \endgroup
  \def\eolintabular{%
    \catcode`\^^M=\active
    \let~\mybreak
  }%
}
%    \end{macrocode}
% \end{macro}
% \subsection{tabbing}
% This will be analog to the |\exceltabular|. You write your tabbing using tabs and <enter>. That’s it :)
% \begin{macro}{\alttabbing}
%     \begin{macrocode}
% 
%     \end{macrocode}
% 
% \end{macro}

% \section{Math stuff}
% \subsection{braces}
% \begin{macro}{\newbraces}
% \begin{macro}{\oldbraces}
% Now this is something most \LaTeX-beginners don’t recognize and wonder why the formula looks so ugly: The braces () do not fit to the hight of the formula. This can be achieved by putting |\left| and |\right| in front of the braces. But actually, this is annoying! In almost any case you want this behaviour, so this should be the standard. So we redefine the way braces are handled. With |\newbraces| the ( ) always fit. If you prefer the normal \LaTeX\ way, use |\oldbraces| to reset everything. This new behaviour should be extended to other characters like \verb~| [ { <~ and so on. Maybe in some later version.
% 
% I would have never been able to implement this without the help of the mailinglist members of |tex-d-l@listserv.dfn.de|!\todo{The newbraces does \emph{not} work at the moment!}
% 
% The redefinition of |\mathstrut| is necessary when using amsmath (you will use amsmath when typesetting formulae, won’t you?), because the hight of formulae is determinated by the hight of a brace. But using ( ) as |\active| characters, we need another brace here. So we take |[|. This will probably also change. But the code is working fine for ( ).\todo{Maybe one could ”temporarily hardcode“ the hight of [ and then use this…}
%    \begin{macrocode}
\makeatletter
\def\resetMathstrut@{%
    \setbox\z@\hbox{%
      \mathchardef\@tempa\mathcode`\[\relax
      \def\@tempb##1"##2##3{\the\textfont"##3\char"}%
      \expandafter\@tempb\meaning\@tempa \relax
    }%
  \ht\Mathstrutbox@\ht\z@ \dp\Mathstrutbox@\dp\z@
}
\makeatother

{\catcode`(\active \xdef({\left\string(}}
{\catcode`)\active \xdef){\right\string)}}

\def\newbraces{
  \mathcode`("8000
  \mathcode`)"8000
}

\edef\oldbraces{
  \mathcode`(\the\mathcode`(
  \mathcode`)\the\mathcode`)
}
%    \end{macrocode}
% \end{macro}
% \subsection{huge display math}
% \begin{environment}{hugedisplaymath}
% Sometimes, especially in presentations, you might need an really big formula. Imagine two hours of struggle with transformations—and finally there is the beautiful formula. Now you can say\\
% \begin{center}|\begin{hugedisplaymath} E = mc^2 \end{hugedisplaymath}| \end{center}
% There should be several steps of size, maybe.
%    \begin{macrocode}
\def\hugedisplaymath{
  \makeatletter
    \makeatother
  \Huge
    \begin{equation*}
}
\def\endhugedisplaymath{
  \end{equation*}
}
%    \end{macrocode}
% \end{environment}
% 
% \subsection{unicode math}
% Typing math in \TeX{} is no great fun – you have to write things like |\int| instead of |∫| and so on. Have a look at the following formula:
% 
% |\int_\infty^\infty \sum_a|
% 
% {∫}
% The code again is stolen and I don’t understand, why it does what it does, but it does it: The first argument is the character you want to use for “unicode math“, the second one is the \TeX-command.
%    \begin{macrocode}
\makeatletter
\def\altmath#1#2{%
  \expandafter\ifx\csname cc\string#1\endcsname\relax
    \add@special{#1}%
    \expandafter
    \xdef\csname cc\string#1\endcsname{\the\catcode`#1}%
    \begingroup
      \catcode`\~\active  \lccode`\~`#1%
      \lowercase{%
      \global\expandafter\let
         \csname ac\string#1\endcsname~%
      \expandafter\gdef\expandafter~\expandafter{#2}}%
    \endgroup
    \global\catcode`#1\active
  \else
  \fi
}
\makeatother
%    \end{macrocode}
% We will make a switch to turn this stuff on or off, so it does not interfere with the unicode-math package. This list will increase by time. If you are missing a symbol, just send me the |\altmath{X}{\Xcode}|-line. I would be very thankful if anybody could send me a whole list of symbols!
%    \begin{macrocode}
\def\makealtmath{
\altmath{α}\alpha
\altmath{β}\beta
\altmath{γ}\gamma
\altmath{δ}\delta

\altmath{⇒}\Rightarrow
\altmath{⇐}\Leftarrow
\altmath{⇔}\Leftrightarrow

\altmath{∫}\int
\altmath{∀}\forall
}
%    \end{macrocode}
% There will be an |\makenormalmath|-switch as well.
% \subsection{Lazy underscript and superscript}
% \begin{macro}{_}
% Sometimes one has to make extensive use of subscripts and superscripts, e.\,g. when typing long formulae including tensors. Then it is a bit annoying to always write the |{}|, especially when there are only two letters in the sub/superscript. So let’s try to implement the possibility to type |$F_μν F^μν $|.
% \todo{An underscore at the end of an inline-formula has to be ended with \} or egroup. That is not nice…}
% 
% First, store the actual meaning of |_| and |^| in |\oldunderscore| and |\oldhat|. \todo{The redefinition of hat does not work because TeX uses it for definition of catcodes. There has to be a really tricky way to get around that.}
%    \begin{macrocode}
\let\oldunderscore_\relax
\let\oldhat^\relax
%    \end{macrocode}
% Now set |_| as |\active| char and define it the way we want it to behave. For this, we need the space char and end-of-line char to be an egroup char. So the underscript group is ended by space or eol and we don’t need to close it explicitly.
%    \begin{macrocode}
\catcode`\_=13
\def_{%
  \ifmmode
    \catcode`\ =2\relax%
    \catcode`\^^M=2\relax%
    \expandafter\oldunderscore\bgroup%
  \else%
    \textunderscore%
  \fi%
}

\iffalse
This does not work so far…
\catcode`\^=13
\def^{%
  \ifmmode
    \catcode`\ =2\relax%
    \catcode`\^^M=2\relax%
    \expandafter\oldhat\bgroup%
  \else%
    \oldhat%
  \fi%
}
\fi
%    \end{macrocode}
% To give the possibility to swith between normal and |alttex| behaviour, store the new underscore.
%    \begin{macrocode}
\let\advancedunderscore_
%    \end{macrocode}
% And the switches. By default, |_| is active. Type |\oldUnder| to get the normal |_|. \todo{The newUnder does not work so far.}
%    \begin{macrocode}
\def\oldUnder{
  \global\catcode`\_=8\relax
}
\def\newUnder{
  \global\let_\advancedunderscore
}
%    \end{macrocode}
% \end{macro}
% 
% \section{Lists and such things}
% \subsection{itemize with a single character}
% \begin{macro}{• instead of \item}
% Here we use an active character (mostly a unicode character bullet •) for the whole construct. And another one for nested itemizations (like a triangular bullet \nolinebreak{\fontspec[Scale=0.8]{DejaVu Sans Mono}‣}).
% 
% This does—guess it—not work correctly so far. I’m trying to find a tricky way so that the ending character is not necessary any more. So far one has to end an itemize with something like an |—| (em-dash). There will also be a possibility to change the characters responsible for the whole action.
% 
% \begin{macro}{\newitemi}
% \begin{macro}{\newitemii}
% The following ugly peace of code is writen by me, defining the conditional insertion of the |\begin{itemize}|. This will be assigned to an active character using |\makeitemi| and |\makeitemii|, respectively.\todo{insideitemize wird nicht zurückgesetzt!!}
%    \begin{macrocode}
\def\outside{o}
\def\inside{i}
\let\insideitemizei\outside
\let\insideitemizeii\outside
%    \end{macrocode}
% The end of itemizei and itemizeii:
%    \begin{macrocode}
\def\altenditemize{
  \if\altlastitem 1%
    \let\altlastitem0%
  \else%
    \end{itemize}%
    \let\insideitemizei\outside%
  \fi%
}

\begingroup
  \lccode`\~=`\^^M%
\lowercase{%
  \endgroup
  \def\makeenteractive{%
    \catcode`\^^M=\active
    \let~\altenditemize
}%
}

\def\newitemi{%
  \ifx\insideitemizei\inside%
    \let\altlastitem1%
    \expandafter\item%
  \else%
    \begin{itemize}%
    \let\insideitemizei\inside%
    \let\altlastitem1%
    \makeenteractive%
    \expandafter\item%
  \fi
}

\def\newitemii{
  \ifx\insideitemizeii\inside
    \expandafter\item%
  \else
    \begin{itemize}
      \let\insideitemizeii\inside
      \expandafter\item%
  \fi
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% Ok, the following code is stolen from the |shortvrb| package, and I don’t understand anything of it. But I keep on trying… nevertheless, it’s working fine, as far as I can see.
% \begin{macro}{\makeitemi}
% \begin{macro}{\makeitemii}
% With this macro, you can define the character you want to use for first-level itemize. (Guess the sense of |\makeitemii|…) Default ist |•| for first-level and |‣| for second-level. Maybe this will be extended till fourth level. More doesn‘t seem to make any sense.
%    \begin{macrocode}
% 
\makeatletter
\def\makeitemi#1{%
  \expandafter\ifx\csname cc\string#1\endcsname\relax
    \add@special{#1}%
    \expandafter
    \xdef\csname cc\string#1\endcsname{\the\catcode`#1}%
    \begingroup
      \catcode`\~\active  \lccode`\~`#1%
      \lowercase{%
      \global\expandafter\let
         \csname ac\string#1\endcsname~%
      \expandafter\gdef\expandafter~\expandafter{\newitemi}}%
    \endgroup
    \global\catcode`#1\active
  \else
  \fi
}

\def\makeitemii#1{%
  \expandafter\ifx\csname cc\string#1\endcsname\relax
    \add@special{#1}%
    \expandafter
    \xdef\csname cc\string#1\endcsname{\the\catcode`#1}%
    \begingroup
      \catcode`\~\active  \lccode`\~`#1%
      \lowercase{%
      \global\expandafter\let
         \csname ac\string#1\endcsname~%
      \expandafter\gdef\expandafter~\expandafter{\newitemii}}%
    \endgroup
    \global\catcode`#1\active
  \else
  \fi
}
%    \end{macrocode}
% \end{macro}\end{macro}
% Now there are the two helperfunctions – no guess what they are really doing.
%    \begin{macrocode}
\def\add@special#1{%
  \rem@special{#1}%
  \expandafter\gdef\expandafter\dospecials\expandafter
{\dospecials \do #1}%
  \expandafter\gdef\expandafter\@sanitize\expandafter
{\@sanitize \@makeother #1}}
\def\rem@special#1{%
  \def\do##1{%
    \ifnum`#1=`##1 \else \noexpand\do\noexpand##1\fi}%
  \xdef\dospecials{\dospecials}%
  \begingroup
    \def\@makeother##1{%
      \ifnum`#1=`##1 \else \noexpand\@makeother\noexpand##1\fi}%
    \xdef\@sanitize{\@sanitize}%
  \endgroup}
\makeatother
%    \end{macrocode}
% \end{macro}
% \subsection{enumerate with a single character}
% \begin{macro}{¹, ²}
% And we do just the same stuff with |\enumerate|. But here we take the character |¹| as first level item, the |²|\footnote{Maybe this is a very stupid idea, because now the |²| cannot be used as a square in mathmode. Of course there could be a test |ifmmode|, but I rather would like to find a better character for |enumerate|.} as second level etc. This may be confusing some way, but just try it.
%
% For the implementation: copy-pasted the code above, nothing interesting so far.
%    \begin{macrocode}
\def\¹{\end{enumerate}}
\def\²{\end{enumerate}}

\let\insideenumi\outside
\let\insideenumii\outside

\def\newenumi{
  \ifx\insideenumi\inside
    \expandafter\item%
  \else
    \begin{enumerate}
      \let\insideenumi\inside
      \expandafter\item%
  \fi
}

\def\newenumii{
  \ifx\insideenumii\inside
    \expandafter\item%
  \else
    \begin{enumerate}
      \let\insideenumii\inside
      \expandafter\item%
  \fi
}

%    \end{macrocode}
% We use the same methods as above, still not understanding, what they are doing. Just changing two lines of code and hoping, everything will be fine.
%    \begin{macrocode}
\makeatletter
\def\makeenumi#1{%
  \expandafter\ifx\csname cc\string#1\endcsname\relax
    \add@special{#1}%
    \expandafter
    \xdef\csname cc\string#1\endcsname{\the\catcode`#1}%
    \begingroup
      \catcode`\~\active  \lccode`\~`#1%
      \lowercase{%
      \global\expandafter\let
         \csname ac\string#1\endcsname~%
      \expandafter\gdef\expandafter~\expandafter{\newenumi}}%
    \endgroup
    \global\catcode`#1\active
  \else
  \fi
}

\def\makeenumii#1{%
  \expandafter\ifx\csname cc\string#1\endcsname\relax
    \add@special{#1}%
    \expandafter
    \xdef\csname cc\string#1\endcsname{\the\catcode`#1}%
    \begingroup
      \catcode`\~\active  \lccode`\~`#1%
      \lowercase{%
      \global\expandafter\let
         \csname ac\string#1\endcsname~%
      \expandafter\gdef\expandafter~\expandafter{\newenumii}}%
    \endgroup
    \global\catcode`#1\active
  \else
  \fi
}
\makeatother

%    \end{macrocode}
% \end{macro}
% Finally, we set the default characters for the items and enumerations:
%    \begin{macrocode}
\makeitemi•
\makeitemii‣
\makeenumi¹
\makeenumii²
%    \end{macrocode}
% And that’s it.\begin{center}\Large Happy alt\TeX{}ing!\end{center}
% \newpage\appendix
% \section*{A very short introduction to \XeLaTeX}
% \label{xelatex}
  % Everything you have to know about \XeLaTeX\ to use this package: Write your \LaTeX\ file just as you are used to. But save it as utf8-encoded, and say
% \begin{verbatim}\usepackage{xltxra}\end{verbatim}
% instead of 
% \begin{verbatim}\usepackage[latin1]{inputenc} and \usepackage[T1]{fontenc}\end{verbatim}
% 
% This loads some files that provide all the cool stuff \XeLaTeX\ offers. You don’t have to take care of letters \TeX\ would not understand – \XeTeX\ understands every character you type. But sometimes the font may not have the symbol for this – then you can use |\fontspec{fontname}|, where |fontname| is the name of a font on your system, e.\,g. |Arno Pro|, |Linux Libertine|, |LT Zapfino One| etc.
% 
% Then, you compile your document with the command |xelatex file.tex|, instead of |latex file.tex| and you get a pdf as output. Mostly, your editor will not have a shortcut to start \XeLaTeX. In that case, you have to compile via the command line. If you know your editor well enough, you may be able to create a shortcut that will run |xelatex file.tex| for you. Notice that you will need an editor that is utf8-capable! One last warning: While \XeTeX\ is not an pdf\TeX\ successor, you cannot use microtypographic extensions. Maybe in the future there will be an implementation that uses advanced OpenType-features, but at the moment there is no microtypography possible!
% 
% If you have any trouble using \XeLaTeX, just e-mail me!
% \newpage
% \section*{todo}
% Here a section with some ideas that could be implemented.
% \begin{itemize}
% \item Use |²| as square in mathmode and possibly |¹| as |\footnote|?
% \item Do something to enable easy tabular
% \item If there is only one char after an |_|, there should no space be needed.
% \item Maybe there could be a ConTeXt-version of this file.
% \end{itemize}
% \Finale
\endinput