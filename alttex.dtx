% \iffalse
% This is alttex.dtx, a small experimental package.
% 
% This code is public domain.
% 
%% Author: Arno L. Trautmann, mail: arno dot trautmann at gmx dot de
%%
%
%<+package|driver>
%<+package>\NeedsTeXFormat{LaTeX2e}
%<+package>\ProvidesPackage{alttex}[]
%
%<*driver>
%\documentclass[12pt]{ltxdoc}
% \usepackage{alttex}
\documentclass{ltxdoc}
\usepackage{ifxetex}
\ifxetex
  \usepackage{xltxtra}
\else
  \errmessage{No XeLaTeX -> no alttex! See the log for more information.}
  \typeout{^^J%
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!^^J%
  ! This package can only be compiled with XeLaTeX.^^J%
  ! pdfLaTeX cannot handle unicode the way it is used here.^^J%
  ! If you want to have support for [utf8]inputenc,^^J%
  ! please contact the author.^^J%
  ! If you want to use LuaLaTeX, give it a try:^^J%
  ! comment out the lines 32, 33, 35–43.^^J%
  ! Please e-mail me the result of your experiences!^^J%
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!^^J%
  }
  \endinput
\fi
\usepackage[english]{babel}
\usepackage{todonotes}

\title{The \textsf{alttex} package}
\author{Arno L. Trautmann\thanks{arno.trautmann@gmx.de}}
\date{Version 0.a.1 \today}

\def\deja{\fontspec{DejaVu Sans Mono}} % to get some fancy characters

\begin{document}
\maketitle
\DocInput{alttex.dtx}
\end{document}
%</driver>
%
% \fi
% 
% This is the package |alttex| which will try to give an experimental new way to write \XeLaTeX{}\footnote{If you don’t know about \XeLaTeX, see the appendix.\ref{xelatex}} code. So far it is mostly done with very dirty code and actually it’s a collection of things that come into my mind during boring lectures. Maybe someone will have fun with the following code fragments.
% \tableofcontents
% \newpage
% \section{introduction}
% The problem I have with \LaTeX\footnote{I’ll write \LaTeX{} instead of \XeLaTeX—saves me two keystrokes. Most of the code below \emph{only} works with \XeLaTeX. If you need support for [utf8]inputenc or Lua\LaTeX, please contact the author.}  is the antique way of typing. Because most people still use a hopelessly outdated keyboard layout („qwerty“ or slightly adapted versions of that), \LaTeX{} doesn’t make use of some cool features. I’m not talking about writing chinese or arabic text! Maybe this example will make the idea clear:
% 
% In standard \LaTeX, one has to write
% \begin{verbatim}
% This is the normal text, then comes the itemization:
% \begin{itemize}
%   \item text for first item
%   \item \begin{itemize}
%         \item this is an item inside an item…
%         \item[$\Rightarrow$] Here an item with a formula: $\int_a^b x^2 dx$
%         \end{itemize}
%   \item and the outer itemize goes on…
% \end{itemize}
% \end{verbatim}
% 
% Using this package and having a superior keyboard layout\footnote{E.\,g. the ergonomic layout NEO.}, you can simply write:\footnote{The lmodern font I’m using here does not have the symbol for the inner item , so we change to DejaVu Sans Mono here.}
% {\setmonofont[Scale=0.85]{DejaVu Sans Mono}
% \begin{verbatim}
% This is the normal text, then comes the itemization:
% 
% • text for first item
% • 
% 
%   ‣ this is an item inside an item
%   ‣[⇒] Here an item with a formula: $∫_a^b x² dx$
%   
% • and the outer itemize goes on…
% 
% And your normal text goes on…
% \end{verbatim}}
% Well, actually I’m lying now because this is not fully implemented so far. But it’s the aim of this package to provide this – besides many, many other funny and cool things. The aim is to offer a more „wysiwyg“ way, without loosing anything of logical markup. One still can re|\def|ine the |•| if he doesn’t like the way his items look.
% I have just started to write the package, there will be much more stuff here in the future.
% 
% Ok, enough blahblah, now comes the code. We begin with the uninteresting preamble stuff:
%    \begin{macrocode}
\ProvidesPackage{alttex}

\RequirePackage{amsmath}
%    \end{macrocode}
% \begin{macro}{\usepackage}
% Now, this is the first highlight. It is an extremely simple and stupid approach to load missing packages on-the-fly, just like Mik\TeX{} does. We re|\def|ine the |\usepackage| and hope, it works. Only working with texlive! If you’re using Mik\TeX{}, put a
% \begin{verbatim}  \let\usepacke\oldpackage\end{verbatim} into your preamble, \emph{directly} after loading |alttex|. If this does not work, delete the following lines from your |alttex.sty|.
%    \begin{macrocode}
\let\oldpackage\usepackage
\def\usepackage#1{
  \AtBeginDocument{hallo}
  \IfFileExists{#1.sty}{
    \oldpackage{#1}
  }{
    \immediate\write18{tlmgr install #1}
  }
}
%    \end{macrocode}
% \end{macro}
% So far, this code seems to be a bit buggy, but it should work anyhow.
% 
% Now load some nice packages and testing wether you’re running \XeLaTeX{} or not.
%    \begin{macrocode}
\RequirePackage{exscale}
\RequirePackage{ifxetex}
\RequirePackage{hhline}
\ifxetex
\typeout{Loading XeTeX, everything’s fine.}
\else
  \typeout{^^J%
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!^^J%
  ! This package can only be compiled with XeLaTeX.^^J%
  ! pdfLaTeX cannot handle unicode the way it is used here.^^J%
  ! If you want to have support for [utf8]inputenc, please contact the author.^^J%
  ! If you want to use LuaLaTeX, give it a try:^^J%
  ! comment out the lines 32,33,35–43.^^J%
  ! Please e-mail me the result of your experiences!^^J%
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!^^J%
  }
  \errmessage{No XeLaTeX, no alttex. See the log for more information.}
  \endinput
\fi

%    \end{macrocode}
% We need |exscale| to write really big formulae, and |ifxetex| to check wether one uses the correct engine.
% \section{Textmode}
% \subsection{no escape}
% \begin{macro}{\noescape}
% You want to write plain text. Maybe you’re annoyed by always escaping characters like \_ \^ \# \& \{ \} \$ \textasciitilde{} and so on. |\noescape| allows you to never escape anything—except the \textbackslash, which still might be used for |\textit{}| or so. Or maybe not… because the \{ \} are not escaped. Have to think about this one. Maybe the \textbackslash{} will be redefined to define \{ \} by itself.
%    \begin{macrocode}
\def\noescape{
  \catcode`\_= 11%
  \catcode`\^= 11%
  \catcode`\#= 11%
  \catcode`\&= 11%
  %\catcode`\{= 11%
  %\catcode`\}= 11%
  \catcode`\$= 11%
  \catcode`\~= 11%
  \makeatletter%
  \catcode`\%= 11
}
%    \end{macrocode}
% The |\makeatletter| is not necessary. But it fitted into this line, so I will leave it here.
% \end{macro}
% \begin{macro}{\oldescape}
% Of course this has to be reset when doing anything like formula, tabular etc. Maybe I will be able to change the behaviour automatically. This idea has been inspired by a discussion on the Con\TeX{}t mailinglist.
%    \begin{macrocode}
\def\oldescape{
  \catcode`\%= 14%
  \catcode`\_= 8%
  \catcode`\^= 7%
  \catcode`\#= 6%
  \catcode`\&= 4%
  %\catcode`\{= 1%
  %\catcode`\}= 2%
  \catcode`\$= 3%
  \catcode`\~= 13%
  \makeatother%
}
%    \end{macrocode}
% \end{macro}
% \subsection{tabular}
% The way one has to type extensive tables is quite complex – and the resulting code is often not really readable. I don’t have good ideas how to change this, but I’m thinking about it. Just a reminder to myself… mail me any suggestions for this!
%
% This will be the first attempt to make tabulars easier: Mostly you want an |\hline| after an |\\|. So let’s try something like:\todo{I will try to implement cool stuff from the \textsf{hhline}-package.}
% \begin{macro}{\§ for \\\hhline}
% Type |\§| at the end of a line, and you get an |\hhline|:
%    \begin{macrocode}
\def\§{\\ \hhline}
%    \end{macrocode}
% This is shurely not a good symbol for this purpose, but I don’t have a better idea so far. At least it’s a ”bar“, so one can guess what it should do. 
% \end{macro}
% 
% \section{Math stuff}
% \subsection{braces}
% \begin{macro}{\newbraces}
% \begin{macro}{\oldbraces}
% Now this is something most \LaTeX-beginners don’t recognize and wonder why the formula looks so ugly: The braces () do not fit to the hight of the formula. This can be achieved by putting |\left| and |\right| in front of the braces. But actually, this is annoying! In almost any case you want this behaviour, so this should be the standard. So we redefine the way braces are handled. With |\newbraces| the ( ) always fit. If you prefer the normal \LaTeX\ way, use |\oldbraces| to reset everything. This new behaviour should be extended to other characters like \verb~| [ { <~ and so on. Maybe in some later version.
% 
% I would have never been able to implement this without the help of the mailinglist members of |tex-d-l@listserv.dfn.de|!
% 
% The redefinition of |\mathstrut| is necessary when using amsmath (you will use amsmath when typesetting formulae, won’t you?), because the hight of formulae is determinated by the hight of a brace. But using ( ) as |\active| characters, we need another brace here. So we take |[|. This will probably also change. But the code is working fine for ( ).\todo{Maybe one could ”temporarily hardcode“ the hight of [ and then use this…}
%    \begin{macrocode}
\makeatletter
\def\resetMathstrut@{%
    \setbox\z@\hbox{%
      \mathchardef\@tempa\mathcode`\[\relax
      \def\@tempb##1"##2##3{\the\textfont"##3\char"}%
      \expandafter\@tempb\meaning\@tempa \relax
    }%
  \ht\Mathstrutbox@\ht\z@ \dp\Mathstrutbox@\dp\z@
}
\makeatother

\edef\oldbraces{
  \mathcode`(\the\mathcode`(
  \mathcode`)\the\mathcode`)
}
\begingroup
  \catcode`(\active \xdef({\left\string(}
  \catcode`)\active \xdef){\right\string)}
\endgroup

\def\newbraces{
  \mathcode`("8000
  \mathcode`)"8000
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \subsection{huge display math}
% \begin{environment}{hugedisplaymath}
% Sometimes, especially in presentations, you might need an really big formula. Imagine two hours of struggle with transformations—and finally there is the beautiful formula. Now you can say\\
% \begin{center}|\begin{hugedisplaymath} E = mc^2 \end{hugedisplaymath}| \end{center}
% There should be several steps of size, maybe.
%    \begin{macrocode}
\def\hugedisplaymath{
  \makeatletter
    \makeatother
  \Huge
    \begin{equation*}
}
\def\endhugedisplaymath{
  \end{equation*}
}
%    \end{macrocode}
% \end{environment}
% 
% \subsection{unicode math}
% Typing math in \TeX{} is no great fun – you have to write things like |\int| instead of {\deja ∫} and so on. Have a look at the following formula:
% 
% |\int_\infty^\infty \sum_a|
% 
% {\deja ∫}
% The code again is stolen and I don’t understand, why it does what it does, but it does it: The first argument is the character you want to use for “unicode math“, the second one is the \TeX-command.
%    \begin{macrocode}
\makeatletter
\def\altmath#1#2{%
  \expandafter\ifx\csname cc\string#1\endcsname\relax
    \add@special{#1}%
    \expandafter
    \xdef\csname cc\string#1\endcsname{\the\catcode`#1}%
    \begingroup
      \catcode`\~\active  \lccode`\~`#1%
      \lowercase{%
      \global\expandafter\let
         \csname ac\string#1\endcsname~%
      \expandafter\gdef\expandafter~\expandafter{#2}}%
    \endgroup
    \global\catcode`#1\active
  \else
  \fi
}
\makeatother
%    \end{macrocode}
% We will make a switch to turn this stuff on or off, so it does not interfere with the unicode-math package. This list will increase by time. If you are missing a symbol, just send me the |\altmath{X}{\Xcode}|-line. I would be very thankful if anybody could send me a whole list of symbols!
%    \begin{macrocode}
\def\makealtmath{
\altmath{α}\alpha
\altmath{β}\beta
\altmath{γ}\gamma
\altmath{δ}\delta

\altmath{⇒}\Rightarrow
\altmath{⇐}\Leftarrow
\altmath{⇔}\Leftrightarrow

\altmath{∫}\int
\altmath{∀}\forall
}
%    \end{macrocode}
% There will be an |\makenormalmath|-switch as well.
% \section{Lists and such things}
% \subsection{itemize with a single character}
% \begin{macro}{• instead of \item}
% Here we use an active character (mostly a unicode character bullet •) for the whole construct. And another one for nested itemizations (like a triangular bullet \nolinebreak{\fontspec[Scale=0.8]{DejaVu Sans Mono}‣}).
% 
% This does—guess it—not work correctly so far. I’m trying to find a tricky way so that the ending character is not necessary any more. So far one has to end an itemize with something like an |—| (em-dash). There will also be a possibility to change the characters responsible for the whole action.\footnote{The triangular bullet sign does not appear here – the font is lacking it…}
% 
% \begin{macro}{\newitemi}
% \begin{macro}{\newitemii}
% The following ugly peace of code is writen by me, defining the conditional insertion of the |\begin{itemize}|. This will be assigned to an active character using |\makeitemi| and |\makeitemii|, respectively.\todo{insideitemize wird nicht zurückgesetzt!!}
%    \begin{macrocode}
\def\outside{o}
\def\inside{i}
\let\insideitemizei\outside
\let\insideitemizeii\outside
%    \end{macrocode}
% The end of itemizei and itemizeii:
%    \begin{macrocode}
\def\•{\end{itemize}}
\def\‣{\end{itemize}}

\def\newitemi{
  \ifx\insideitemizei\inside
    \expandafter\item%
  \else
    \begin{itemize}
    \let\insideitemizei\inside
    \expandafter\item%
  \fi
}

\def\newitemii{
  \ifx\insideitemizeii\inside
    \expandafter\item%
  \else
    \begin{itemize}
      \let\insideitemizeii\inside
      \expandafter\item%
  \fi
}
%    \end{macrocode}
% \end{macro}\end{macro}
% Ok, the following code is stolen from the |shortvrb| package, and I don’t understand anything of it. But I keep on trying… nevertheless, it’s working fine, as far as I can see.
% \begin{macro}{\makeitemi}
% \begin{macro}{\makeitemii}
% With this macro, you can define the character you want to use for first-level itemize. (Guess the sense of |\makeitemii|…) Default ist |•| for first-level and |‣| for second-level. Maybe this will be extended till fourth level. More doesn‘t seem to make any sense.
%    \begin{macrocode}
% 
\makeatletter
\def\makeitemi#1{%
  \expandafter\ifx\csname cc\string#1\endcsname\relax
    \add@special{#1}%
    \expandafter
    \xdef\csname cc\string#1\endcsname{\the\catcode`#1}%
    \begingroup
      \catcode`\~\active  \lccode`\~`#1%
      \lowercase{%
      \global\expandafter\let
         \csname ac\string#1\endcsname~%
      \expandafter\gdef\expandafter~\expandafter{\newitemi}}%
    \endgroup
    \global\catcode`#1\active
  \else
  \fi
}

\def\makeitemii#1{%
  \expandafter\ifx\csname cc\string#1\endcsname\relax
    \add@special{#1}%
    \expandafter
    \xdef\csname cc\string#1\endcsname{\the\catcode`#1}%
    \begingroup
      \catcode`\~\active  \lccode`\~`#1%
      \lowercase{%
      \global\expandafter\let
         \csname ac\string#1\endcsname~%
      \expandafter\gdef\expandafter~\expandafter{\newitemii}}%
    \endgroup
    \global\catcode`#1\active
  \else
  \fi
}
%    \end{macrocode}
% \end{macro}\end{macro}
% Now there are the two helperfunctions – no guess what they are really doing.
%    \begin{macrocode}
\def\add@special#1{%
  \rem@special{#1}%
  \expandafter\gdef\expandafter\dospecials\expandafter
{\dospecials \do #1}%
  \expandafter\gdef\expandafter\@sanitize\expandafter
{\@sanitize \@makeother #1}}
\def\rem@special#1{%
  \def\do##1{%
    \ifnum`#1=`##1 \else \noexpand\do\noexpand##1\fi}%
  \xdef\dospecials{\dospecials}%
  \begingroup
    \def\@makeother##1{%
      \ifnum`#1=`##1 \else \noexpand\@makeother\noexpand##1\fi}%
    \xdef\@sanitize{\@sanitize}%
  \endgroup}
\makeatother
%    \end{macrocode}
% \end{macro}
% \subsection{enumerate with a single character}
% \begin{macro}{¹, ²}
% And we do just the same stuff with |\enumerate|. But here we take the character |¹| as first level item, the |²|\footnote{Maybe this is a very stupid idea, because now the |²| cannot be used as a square in mathmode. Of course there could be a test |ifmmode|, but I rather would like to find a better character for |enumerate|.} as second level etc. This may be confusing some way, but just try it.
%
% For the implementation: copy-pasted the code above, nothing interesting so far.
%    \begin{macrocode}
\let\insideenumi\outside
\let\insideenumii\outside

\def\newenumi{
  \ifx\insideenumi\inside
    \expandafter\item%
  \else
    \begin{enumerate}
      \global\let\insideenumi\inside
      \expandafter\item%
  \fi
}

\def\newenumii{
  \ifx\insideenumii\inside
    \expandafter\item%
  \else
    \begin{enumerate}
      \global\let\insideenumii\inside
      \expandafter\item%
  \fi
}

%    \end{macrocode}
% We use the same methods as above, still not understanding, what they are doing. Just changing two lines of code and hoping, everything will be fine.
%    \begin{macrocode}
\makeatletter
\def\makeenumi#1{%
  \expandafter\ifx\csname cc\string#1\endcsname\relax
    \add@special{#1}%
    \expandafter
    \xdef\csname cc\string#1\endcsname{\the\catcode`#1}%
    \begingroup
      \catcode`\~\active  \lccode`\~`#1%
      \lowercase{%
      \global\expandafter\let
         \csname ac\string#1\endcsname~%
      \expandafter\gdef\expandafter~\expandafter{\newenumi}}%
    \endgroup
    \global\catcode`#1\active
  \else
  \fi
}

\def\makeenumii#1{%
  \expandafter\ifx\csname cc\string#1\endcsname\relax
    \add@special{#1}%
    \expandafter
    \xdef\csname cc\string#1\endcsname{\the\catcode`#1}%
    \begingroup
      \catcode`\~\active  \lccode`\~`#1%
      \lowercase{%
      \global\expandafter\let
         \csname ac\string#1\endcsname~%
      \expandafter\gdef\expandafter~\expandafter{\newenumii}}%
    \endgroup
    \global\catcode`#1\active
  \else
  \fi
}
\makeatother

%    \end{macrocode}
% \end{macro}
% Finally, we set the default characters for the items and enumerations:
%    \begin{macrocode}
\makeitemi•
\makeitemii‣
\makeenumi¹
\makeenumii²
%    \end{macrocode}
% And that’s it.\begin{center}\Large Happy alt\TeX{}ing!\end{center}
% \newpage\appendix
% \section*{A very short introduction to \XeLaTeX}
% \label{xelatex}
  % Everything you have to know about \XeLaTeX\ to use this package: Write your \LaTeX\ file just as you are used to. But save it as utf8-encoded, \emph{do not} use \\
%|\usepackage{inputenc}| and |\usepackage{fontenc}|,\\
% but \emph{do use}\\
% |\usepackage{xltxra}|.\\
% This loads some files that provide all the cool stuff \XeLaTeX\ offers. You don’t have to take care of letters \TeX\ would not understand – \XeTeX\ understands every character you type. But sometimes the font may not have the symbol for this – then you can use |\fontspec{fontname}|, where |fontname| is the name of a font on your system, e.\,g. |Arno Pro|, |Linux Libertine| etc.
% Of course, you don’t compile with the command |latex file.tex|, but |xelatex file.tex|. You get a pdf as output. Nevertheless, \XeTeX\ is not pdf\TeX, so you cannot use microtypographic extensions… :(
% 
% If you have any trouble using \XeLaTeX, just mail me!
% \newpage
% \section*{todo}
% Here a section with some ideas that could be implemented.
% \begin{itemize}
% \item Use |²| as square in mathmode and possibly |¹| as |\footnote|?
% \item
% \end{itemize}
% \Finale
\endinput